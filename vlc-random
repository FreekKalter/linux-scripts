#!/home/fkalter/perl
use 5.016000;
use warnings;
use strict;

use Carp;
use IPC::Open3 qw( open3 );
use Path::Tiny;

my $sock                = "/home/fkalter/vlc-random.sock";
my $log                 = "/home/fkalter/log.txt";
my $standard_dir        = "/media/truecrypt4/down/";
my $current_playing_dir = path("/home/fkalter/current_vlc_random");
my $dir;

my ( $read, $write, $pid );

if ( -e $sock ) {
    # if vlc does not respond on current sock-file, delete it and fork new vlc with own new socketfile
    if ( system("echo 'logout' | nc -U $sock") ) {
        unlink $sock;
        &fork_vlc();
    }
    $dir = path($ARGV[0] || $current_playing_dir->slurp);
}
else {
    &fork_vlc();
}

say $dir;
$current_playing_dir->spew($dir);

opendir( my $dh, $dir );
my @files = grep { !/^\.{1,2}/x } readdir($dh);
open( my $lh, ">>", $log ) or croak "Could not open $log for writing: $!";

my $rand = int(rand(scalar @files));

my $to_add = $dir->child($files[$rand]);
print $lh $to_add, "\n";
close $lh;

$pid = open3( $write, $read, $read, qq( echo "add $to_add" | nc -U $sock ) );
waitpid( $pid, 0 );

my $status = do { local $/ = undef; <$read> };
if ( $status =~ /menu select/ ) {
    $pid = open3( $write, $read, $read, qq( echo "pause" | nc -U $sock ) );
    waitpid( $pid, 0 );
    $pid = open3( $write, $read, $read, qq( echo "add $to_add" | nc -U $sock ) );
    waitpid( $pid, 0 );
}
close($lh);

say "$rand/".scalar @files;

sub fork_vlc {
    $dir = path($ARGV[0] || $standard_dir);
    die "could not fork\n" unless defined( $pid = fork );
    if ( !$pid ) {
        exec "vlc --extraintf oldrc --rc-unix $sock > /dev/null 2>&1";
    }

    # wait for vlc to completely startup before moving on
    # asume vlc is started when it has created the socket file
    while( not -e $sock ){
        say "waiting for socket to be created";
       sleep(1);
    }
    while(system("echo 'logout'| nc -U $sock")){
        say "waiting for vlc to completely start";
       sleep(0.5);
    }
    return;
}
